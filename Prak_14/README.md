### Практика 14. Чебыкин Д.К. ПИМО-01-25. Оптимизация запросов к БД. Использование connection pool


### Задача на практику:

1.	Научиться находить «узкие места» в SQL-запросах и устранять их (индексы, переписывание запросов, пагинация, батчинг).
2.	Освоить настройку пула подключений (connection pool) в Go и параметры его тюнинга.
3.	Научиться использовать EXPLAIN/ANALYZE, базовые метрики (pg_stat_statements), подготовленные запросы и транзакции.
4.	Применить техники уменьшения N+1 запросов и сокращения аллокаций на горячем пути.


### Структура проекта

```
Prak_14/
├── api/
│   └── openapi.yaml
├── cmd/
│   └── api/
│       └── main.go
├── internal/
│   ├── config/
│   │   └── config.go
│   ├── http/
│   │   ├── handlers.go
│   │   ├── respond.go
│   │   └── servers.go
│   ├── model/
│   │   └── note.go
│   ├── pagination/
│   │   └── cursor.go
│   └── storage/
│       ├── postgres/
│       │   ├── query.go
│       │   └── repo.go
│       └── redis/
│           └── cache.go
├── docker-compose.yml
├── go.mod
├── go.sum
└── README.md
```



### Запуск проекта

```
cd go_practics
docker-compose up -d
export DATABASE_URL="postgresql://user:pass@localhost:5432/notes?sslmode=disable"
go run ./cmd/api
```


### Создание таблицы в БД
```
CREATE TABLE IF NOT EXISTS notes (
  id BIGSERIAL PRIMARY KEY,
  title TEXT NOT NULL,
  content TEXT NOT NULL,
  created_at TIMESTAMPTZ NOT NULL DEFAULT now()
);

-- Частичный индекс для поиска по заголовку, если часто ищем по prefix
CREATE INDEX IF NOT EXISTS idx_notes_title_gin
  ON notes USING GIN (to_tsvector('simple', title));

-- Индекс для keyset-пагинации
CREATE INDEX IF NOT EXISTS idx_notes_created_id ON notes (created_at, id);
```
![screen_new](./foto/create_table.png)

### Создание заметки
```
curl -v -X POST http://localhost:8080/notes \                    
  -H 'Content-Type: application/json' \
  -d '{"title":"facing the truth","content":"..."}'
```
![screen2](./foto/create_note.png)

### Получение заметки по айди
```
curl -s http://localhost:8080/notes/4       
```
![screen_3](./foto/get_note_by_id.png)

### Keyset пагинация
![screen4](./foto/pagination_1.png)

![screen5](./foto/pagination_2.png)

### Обновление заметки
```
curl -s -X PATCH http://localhost:8080/notes/1 \          
  -H 'Content-Type: application/json' \
  -d '{"title":"postgres knowledge","content":"updated"}'
```
![another](./foto/update_note.png)

### Используем batch
```
curl -s "http://localhost:8080/notes/batch?ids=1,2,3,4"
```
![screen45](./foto/get_notes_batch.png)

### Прогон нагрузки hey
**Пагинация**
![screen23](./foto/hey_pagination.png)

**Получение по id**

(без пагинации)
![id_no_batch](./foto/hey_get_note_by_id.png)

(с пагинации)
![id_batch](./foto/hey_get_batch.png)

### ДО Оптимизации:

1. Пагинация через OFFSET. При использовании OFFSET для пагинации время выполнения запросов росло почти линейно с номером страницы. Чем дальше страница, тем больше строк базе приходилось просканировать.
2. N+1 проблема при получении по ID. При получении списка заметок по ID выполнялось N+1 запросов: один запрос для получения списка ID, затем N отдельных запросов для получения каждой заметки.
3. Неэффективный поиск по title. Поиск по title был реализован через LIKE или неправильное использование полнотекстового поиска. Когда запрос не был написан в точности под выражение индекса, PostgreSQL не мог использовать GIN индекс и уходил в Seq Scan.

### Что изменили:

1. Заменили OFFSET-пагинации на Keyset-пагинацию
Реализована keyset-пагинация (или пагинация по ключу) на основе составного поля (created_at, id). Это позволяет базе данных продолжать чтение «с места» последнего полученного результата, используя эффективный поиск по индексу, вместо полного пересчета смещения.
2. Устранили проблему N+1
Запросы N+1 были заменены на один пакетный (batch) запрос, который загружает все необходимые данные по массиву идентификаторов с использованием оператора ANY().


### Ответы на контрольные вопросы

1. Чем keyset-пагинация лучше OFFSET/LIMIT на больших объемах

Keyset-пагинация использует условие WHERE для фильтрации строк, которые были получены на предыдущей странице, например WHERE created_at <= last_value AND id < last_id. Это позволяет базе данных использовать индекс для эффективного поиска начальной точки и чтения только нужного блока строк. OFFSET/LIMIT заставляет базу данных считать и пропускать все строки до начала нужной страницы, что на глубоких страницах приводит к существенному замедлению и росту нагрузки. Keyset-пагинация обеспечивает постоянную скорость независимо от глубины выборки.

2. Когда нужен покрывающий индекс и чем он отличается от обычного

Покрывающий индекс содержит в себе все поля, необходимые для выполнения запроса, включая те, которые используются в SELECT, JOIN, WHERE и ORDER BY. Обычный индекс обычно включает только поля для фильтрации и сортировки, но для получения остальных данных требуется обращение к основной таблице. Покрывающий индекс позволяет выполнить запрос, обращаясь только к индексу, что исключает дополнительные чтения таблицы. Он нужен для ускорения часто выполняемых запросов, где критически важна скорость.

3. Какие параметры пула подключений в Go вы настраиваете и почему

MaxOpenConns максимальное количество открытых подключений к базе данных. Устанавливается для ограничения нагрузки на БД и исчерпания ресурсов. MaxIdleConns максимальное количество простаивающих подключений в пуле. Позволяет держать готовые подключения для быстрого выполнения запросов без накладных расходов на установку. ConnMaxLifetime максимальное время жизни подключения. Помогает ротации подключений, чтобы избежать использования устаревших или проблемных соединений. Настройки зависят от нагрузки и возможностей базы данных.

4. Что показывает EXPLAIN ANALYZE BUFFERS и как отличить Seq Scan от Index Scan

EXPLAIN ANALYZE показывает фактический план выполнения запроса включая затраченное время. BUFFERS добавляет информацию об использовании кэша сколько блоков было считано с диска и из кэша. Seq Scan последовательное чтение всей таблицы. Index Scan сканирование индекса для выбора строк с последующим обращением к таблице за остальными данными. Seq Scan обычно применяется при чтении большой доли таблицы, Index Scan при выборе небольшой доли строк с использованием индекса.

5. Как устранить N 1 запросов Приведите 2 способа

Первый способ замена нескольких запросов на один батч запрос с использованием оператора IN или ANY для загрузки всех связанных данных по массиву идентификаторов. Второй способ использование JOIN в основном запросе для сразу получения всех нужных данных за один обращение к базе.

6. Когда уместны prepared statements и какие плюсы они дают

Prepared statements уместны при многократном выполнении однотипных запросов с разными параметрами. Плюсы повышение производительности за счет того что план запроса компилируется один раз, безопасность от SQL инъекций так как параметры передаются отдельно от текста запроса, уменьшение сетевых издержек при повторных вызовах.

7. Как выбрать правильный размер пула для сервиса и БД Какие метрики смотреть

Размер пула должен быть достаточным для обработки пиковой нагрузки но не превышать возможности базы данных. Следует смотреть метрики активные подключения к БД, время ожидания подключения из пула, утилизация CPU и памяти на сервере БД, количество ошибок таймаутов. Оптимальный размер часто находится эмпирически начинают с небольшого пула и увеличивают под нагрузкой пока не перестают расти производительность и не появляются признаки конкуренции за ресурсы.