# Практическая работа № 16 - Чебыкин Д.К. ПИМО-01-25

Тема: Интеграционное тестирование API. Использование Docker для тестовой БД

## Цели
-	Освоить интеграционное тестирование REST API: проверка «маршрут → хендлер → сервис → репозиторий → реальная БД».
-	Научиться поднимать изолированную тестовую среду БД в Docker.
-	Освоить 2 подхода к инфраструктуре тестов:
-	A. Локальная среда через docker-compose (просто и наглядно).
-	B. Программный подъём контейнеров через testcontainers-go (изолировано и удобно для CI).
-	Научиться инициализировать схему БД (миграции/auto-migrate), сидировать тестовые данные, очищать окружение.
-	Внедрить интеграционные проверки CRUD-эндпоинтов (статусы, заголовки, JSON-ответы, эффекты в БД).

### Запуск тестов (поднимаем контейнер вручную):

```bash
docker compose up -d
go test -v ./integration/...
docker compose down -v
```


### Запуск тестов:

```
go test -v ./internal/integration/...
```

#### POST и GET записи
![post_get](/foto/test_create_and_get_note.png)

#### GET несуществующей записи
![get_404](/foto/test_get_non_existing_note.png)

#### обновление записи через PUT
![put_get](/foto/test_update_note.png)

#### DELETE записи
![delete](/foto/test_delete_note.png)

#### Пагинация записей
![pagination](/foto/test_list_notes_with_pagination.png)

![pagination](/foto/test_list_all_notes.png)

#### обновление несуществующей записи
![delete](/foto/test_update_non_existing_note.png)

#### DELETE несуществующей записи
![delete](/foto/test_delete_non_existing_note.png)

#### Создание записи с невалиднымJSON
![delete](/foto/test_create_non_valid_json.png)





### Запуск тестов (контейнер поднимается автоматически):

```bash
go test -v ./internal/integration/notes_tc_integration_test.go
```
#### Получение записи
![test_with_container_1.png](foto/test_with_container_1.png)

![test_with_container_2.png](foto/test_with_container_2.png)

## Краткие выводы

В ходе практической работы было реализовано и проверено интеграционное тестирование REST API, охватывающее полный путь обработки запроса: от HTTP-маршрута и хендлера до слоя сервиса, репозитория и реальной базы данных PostgreSQL.
Схема базы данных инициализировалась автоматически при старте тестов с использованием миграций, что обеспечивало корректное создание таблиц и связанных объектов.
Тестовые данные создавались непосредственно в ходе выполнения тестов, что позволило проверять реальные эффекты операций CRUD в базе данных.
Основные проверки включали валидацию HTTP-статусов, структуры JSON-ответов и факта сохранения данных в БД.
В процессе работы было отмечено, что интеграционные тесты требуют более аккуратного управления состоянием БД и изоляции данных между тестами.
Потенциальным улучшением является внедрение строгой идемпотентности тестов, очистки данных через транзакции или TRUNCATE, а также использование заранее подготовленных seed-данных.


### Ответы на контрольные вопросы

**1. Чем интеграционные тесты отличаются от модульных? Когда целесообразно использовать каждый вид?**

Интеграционные тесты проверяют взаимодействие нескольких компонентов системы (например, API с базой данных), а модульные тесты проверяют работу отдельной функции или метода в изоляции. Модульные тесты целесообразно использовать для проверки бизнес-логики, алгоритмов и обработки ошибок внутри одного модуля, когда нужно быстро и часто тестировать изменения. Интеграционные тесты нужны для проверки корректности работы системы в целом, взаимодействия компонентов и соответствия реальному окружению, особенно при работе с внешними сервисами, базами данных или API.

**2. Зачем использовать Docker для БД, если локально уже есть PostgreSQL/MySQL?**

Использование Docker для тестовой базы данных обеспечивает изоляцию тестового окружения от основной системы, позволяет легко управлять версиями СУБД, создавать чистые экземпляры для каждого теста и гарантировать одинаковое поведение на всех машинах разработчиков и в CI/CD. Это исключает риск повредить или заполнить данными рабочую базу, упрощает настройку и очистку, а также позволяет параллельно запускать тесты с разными конфигурациями баз данных.

**3. Плюсы и минусы подходов docker-compose и testcontainers-go для интеграций.**

**docker-compose**:
- Плюсы: простой YAML-файл для описания зависимостей, легко запускать вручную, подходит для локальной разработки, можно использовать один и тот же файл для разработки и тестов.
- Минусы: требует предварительного запуска контейнеров, менее гибкое управление из тестового кода, сложнее интегрировать в CI-пайплайны с параллельным выполнением.

**testcontainers-go**:
- Плюсы: программируемое создание и управление контейнерами из кода тестов, автоматическая очистка после тестов, изоляция между тестами, поддержка разных типов баз данных и версий.
- Минусы: сложнее настройка, требуется Docker-демон во время выполнения тестов, увеличивает время выполнения из-за создания контейнеров, может быть избыточным для простых сценариев.

**4. Как обеспечить независимость интеграционных тестов (данные, транзакции, порядок)?**

Для независимости тестов можно использовать несколько подходов:
1. Очистка базы данных перед каждым тестом через TRUNCATE или DELETE.
2. Использование транзакций с откатом после каждого теста.
3. Создание уникальных данных для каждого теста (например, через случайные идентификаторы).
4. Изоляция тестов через отдельные схемы или базы данных.
5. Запрет зависимости тестов друг от друга и запуск их в случайном порядке.
6. Использование тестовых двойников (моков) для внешних зависимостей.

**5. Как вы бы тестировали пагинацию и фильтрацию в списковых эндпоинтах?**

Для тестирования пагинации нужно:
1. Создать достаточное количество тестовых данных (больше размера страницы).
2. Проверить работу параметров limit и offset, включая граничные случаи (offset больше общего количества, отрицательные значения).
3. Убедиться, что порядок сортировки соответствует ожиданиям.
4. Проверить метаданные (общее количество элементов, номер страницы).

Для фильтрации:
1. Создать данные с различными значениями фильтруемых полей.
2. Проверить все поддерживаемые фильтры по отдельности и в комбинации.
3. Тестировать особые случаи: пустые результаты, частичные совпадения, регистрозависимость.
4. Проверить валидацию параметров фильтрации.

**6. Какие риски несут «ломающие» миграции и как их безопасно применять в тестах?**

«Ломающие» (breaking) миграции могут привести к несовместимости схемы базы данных с текущей версией кода, что вызовет ошибки в тестах и продакшене. Риски включают:
- Потерю данных при изменении структуры таблиц.
- Невозможность отката миграций.
- Конфликты с параллельно выполняющимися операциями.

Для безопасного применения в тестах:
1. Использовать отдельную тестовую базу данных, изолированную от продакшена.
2. Всегда иметь возможность откатить миграцию.
3. Выполнять миграции в транзакциях там, где это возможно.
4. Тестировать миграции на копии данных перед применением к основной базе.
5. Использовать версионирование миграций и проверять их корректность в CI/CD.

**7. Как организовать запуск интеграционных тестов в CI?**

Для запуска интеграционных тестов в CI нужно:
1. Добавить шаг подготовки тестового окружения (запуск контейнера с БД через Docker).
2. Выполнить миграции схемы базы данных.
3. Установить переменные окружения для подключения к тестовой БД.
4. Запустить тесты с флагами для интеграционных тестов (например, `go test -tags=integration ./...`).
5. Обеспечить очистку ресурсов после тестов (остановка контейнеров).
6. Настроить кэширование зависимостей для ускорения выполнения.
7. Добавить обработку ошибок и логирование для отладки проблем.

Пример для GitHub Actions:
```yaml
integration-tests:
  runs-on: ubuntu-latest
  services:
    postgres:
      image: postgres:14
      env:
        POSTGRES_PASSWORD: test
        POSTGRES_DB: notes_test
  steps:
    - uses: actions/checkout@v3
    - name: Run migrations
      run: go run ./cmd/migrate
      env:
        DB_DSN: postgres://postgres:test@localhost:5432/notes_test
    - name: Run integration tests
      run: go test -tags=integration ./integration/...
      env:
        DB_DSN: postgres://postgres:test@localhost:5432/notes_test
```